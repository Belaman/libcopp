libcopp
================

Cross-platform coroutine library in C++ .

|                   |                                       [Linux+OSX(Clang+GCC)][linux-link]                                       |                                          [Windows(VC+MinGW)][windows-link]                                           | [Coveralls][coverage-link] |
| :---------------: | :------------------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------------------------------: | :------------------------: |
| Build & Unit Test |                                                 ![linux-badge]                                                 |                                                   ![windows-badge]                                                   |     ![coverage-badge]      |
|     Compilers     | linux-gcc-4.4 <br /> linux-gcc-4.6 <br /> linux-gcc-4.9 <br /> linux-gcc-9 <br /> macos-apple-clang-9.0 <br /> | MSVC 12(Visual Studio 2013) <br /> MSVC 14(Visual Studio 2015) <br /> MSVC 15(Visual Studio 2017) <br />MSVC 16(Visual Studio 2019) <br /> MinGW64-gcc |                            |

[![GitHub release (latest by date)](https://img.shields.io/github/v/release/owt5008137/libcopp)](https://github.com/owt5008137/libcopp/releases)


![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/owt5008137/libcopp)
![GitHub repo size](https://img.shields.io/github/repo-size/owt5008137/libcopp)
![GitHub forks](https://img.shields.io/github/forks/owt5008137/libcopp?style=social)
![GitHub stars](https://img.shields.io/github/stars/owt5008137/libcopp?style=social)


[linux-badge]: https://travis-ci.org/owt5008137/libcopp.svg?branch=v2 "Travis build status"
[linux-link]:  https://travis-ci.org/owt5008137/libcopp "Travis build status"
[windows-badge]: https://ci.appveyor.com/api/projects/status/7w6dfnpeahfmgaqj/branch/v2?svg=true "AppVeyor build status"
[windows-link]:  https://ci.appveyor.com/project/owt5008137/libcopp "AppVeyor build status"
[coverage-badge]: https://coveralls.io/repos/github/owt5008137/libcopp/badge.svg?branch=v2 "Coveralls coverage"
[coverage-link]:  https://coveralls.io/github/owt5008137/libcopp?branch=v2 "Coveralls coverage"

LICENSE
----------------

License under the MIT license

Document
----------------

Documents can be found at https://libcopp.atframe.work (Generated by doxygen with *[docs/libcopp.doxyfile](docs/libcopp.doxyfile)*).

INSTALL
----------------

> libcopp use cmake to generate makefile and switch build tools.

### Prerequisites

-   **[required]** GCC or Clang or MSVC or clang-cl support ISO C++ 03 and upper
-   **[required]** [cmake](www.cmake.org) 3.7.0 and upper
-   **[optional]** [gtest](https://code.google.com/p/googletest/) 1.6.0 and upper (Better unit test supported)
-   **[optional]** [Boost.Test](http://www.boost.org/doc/libs/release/libs/test/) (Boost.Test supported)

### Unix

-   **[required]** ar, as, ld ([binutils](http://www.gnu.org/software/binutils/)) or [llvm](http://llvm.org/)
-   **[optional]** if using [gtest](https://code.google.com/p/googletest/), pthread is required.

### Windows

-   **[required]** masm (in vc)
-   **[optional]** if using [gtest](https://code.google.com/p/googletest/), pthread is required.

### Install with vcpkg

**1. clone and setup vcpkg**(See more detail on https://github.com/Microsoft/vcpkg)
~~~~~~~~~~bash
git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg

PS> .\bootstrap-vcpkg.bat
Linux:~/$ ./bootstrap-vcpkg.sh
~~~~~~~~~~

**2. install libcopp**
~~~~~~~~~~bash
PS> .\vcpkg install libcopp
Linux:~/$ ./vcpkg install libcopp
~~~~~~~~~~


### Custom Build

**1. clone and make a build directory**
~~~~~~~~~~bash
git clone --single-branch --depth=1 -b master https://github.com/owt5008137/libcopp.git 
mkdir libcopp/build && cd libcopp/build
~~~~~~~~~~

**2. run cmake command**
~~~~~~~~~~bash
# cmake <libcopp dir> [options...]
cmake .. -DLIBCOPP_FCONTEXT_USE_TSX=YES -DPROJECT_ENABLE_UNITTEST=YES -DPROJECT_ENABLE_SAMPLE=YES
~~~~~~~~~~

**3. make libcopp**
~~~~~~~~~~bash
cmake --build . --config RelWithDebInfo # or make [options] when using Makefile
~~~~~~~~~~

**4. run test/sample/benchmark** *[optional]*
~~~~~~~~~~bash
# Run test => Required: PROJECT_ENABLE_UNITTEST=YES
cmake --build . --config RelWithDebInfo --target run_test # or make run_test when using Makefile
# Run sample => Required: PROJECT_ENABLE_SAMPLE=YES
cmake --build . --config RelWithDebInfo --target run_sample # or make run_sample when using Makefile
# Run benchmark => Required: PROJECT_ENABLE_SAMPLE=YES
cmake --build . --config RelWithDebInfo --target benchmark # or make benchmark when using Makefile
~~~~~~~~~~

**5. install** *[optional]*
~~~~~~~~~~bash
cmake --build . --config RelWithDebInfo --target install # or make install when using Makefile
~~~~~~~~~~

> Or you can just copy include directory and libcopp.a in lib or lib64 into your project to use it.

#### CMake Options
Options can be cmake options. such as set compile toolchains, source directory or options of libcopp that control build actions. libcopp options are listed below:

| Option                                     | Description                                                                                                               |
| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| BUILD\_SHARED\_LIBS=YES\|NO                | [default=NO] Build dynamic library.                                                                                       |
| LIBCOPP\_ENABLE\_SEGMENTED\_STACKS=YES\|NO | [default=NO] Enable split stack supported context.(it's only availabe in linux and gcc 4.7.0 or upper)                    |
| LIBCOPP\_ENABLE\_VALGRIND=YES\|NO          | [default=YES] Enable valgrind supported context.                                                                          |
| PROJECT\_ENABLE\_UNITTEST=YES\|NO          | [default=NO] Build unit test.                                                                                             |
| PROJECT\_ENABLE\_SAMPLE=YES\|NO            | [default=NO] Build samples.                                                                                               |
| PROJECT\_DISABLE\_MT=YES\|NO               | [default=NO] Disable multi-thread support.                                                                                |
| LIBCOTASK\_ENABLE=YES\|NO                  | [default=YES] Enable build libcotask.                                                                                     |
| LIBCOPP\_FCONTEXT\_USE\_TSX=YES\|NO        | [default=NO] Enable [Intel Transactional Synchronisation Extensions (TSX)](https://software.intel.com/en-us/node/695149). |
| GTEST\_ROOT=[path]                         | set gtest library install prefix path                                                                                     |
| BOOST\_ROOT=[path]                         | set Boost.Test library install prefix path                                                                                |

USAGE
----------------

### Using with cmake

1. Add <WHERE TO INSTALL libcopp>/lib(64)/cmake to any of **CMAKE_PREFIX_PATH** 、 **CMAKE_FRAMEWORK_PATH** 、 **CMAKE_SYSTEM_PREFIX_PATH** 、 **CMAKE_SYSTEM_FRAMEWORK_PATH**
2. Just add [find_package(Libcopp)](https://cmake.org/cmake/help/latest/command/find_package.html) to use libcopp module.
~~~~~~~~~~cmake
find_package(Libcopp CONFIG REQUIRED)
target_include_directories(main PRIVATE ${Libcopp_INCLUDE_DIRS})
target_link_libraries(main PRIVATE ${Libcotask_LIBRARIES} ${Libcopp_LIBRARIES})
~~~~~~~~~~

See more detail on https://github.com/Microsoft/vcpkg/tree/master/ports/libcopp .

### Directly use headers and libraries

Just include headers and linking library file of your platform to use libcopp.

~~~~~~~~~~bash
LIBCOPP_PREFIX=<WHERE TO INSTALL libcopp>

# Example command for build sample with gcc 4.9 or upper on Linux
for source in sample_readme_*.cpp; do
    g++ -std=c++14 -O2 -g -ggdb -Wall -Werror -fPIC -rdynamic -fdiagnostics-color=auto -Wno-unused-local-typedefs \
        -I$LIBCOPP_PREFIX/include -L$LIBCOPP_PREFIX/lib64 -lcopp -lcotask $source -o $source.exe;
done

# Example command for build sample with clang 3.9 or upper and libc++ on Linux
for source in sample_readme_*.cpp; do
    clang++ -std=c++17 -stdlib=libc++ -O2 -g -ggdb -Wall -Werror -fPIC -rdynamic        \
        -I$LIBCOPP_PREFIX/include -L$LIBCOPP_PREFIX/lib64 -lcopp -lcotask -lc++ -lc++abi  \
        $source -o $source.exe;
done

# AppleClang on macOS just like those scripts upper.
# If you are using MinGW on Windows, it's better to add -static-libstdc++ -static-libgcc to 
#     use static linking and other scripts are just like those on Linux.

~~~~~~~~~~

~~~~~~~~~~powershell
# Example command for build sample with MSVC 1914 or upper on Windows & powershell(Debug Mode /MDd)
foreach ($source in Get-ChildItem -File -Name .\sample_readme_*.cpp) {
    cl /nologo /MP /W4 /wd"4100" /wd"4125" /EHsc /std:c++17 /Zc:__cplusplus /O2 /MDd /I$LIBCOPP_PREFIX/include $LIBCOPP_PREFIX/lib64/copp.lib $LIBCOPP_PREFIX/lib64/cotask.lib $source
}
~~~~~~~~~~

### Get Start & Example

#### coroutine_context example
This is a simple example of using basic coroutine context below:

~~~~~~~~~~cpp
// see https://github.com/owt5008137/libcopp/blob/v2/sample/sample_readme_1.cpp
#include <cstdio>
#include <cstring>
#include <inttypes.h>
#include <iostream>
#include <stdint.h>

// include context header file
#include <libcopp/coroutine/coroutine_context_container.h>

// define a coroutine runner
int my_runner(void *) {
    copp::coroutine_context *addr = copp::this_coroutine::get_coroutine();

    std::cout << "cortoutine " << addr << " is running." << std::endl;

    addr->yield();

    std::cout << "cortoutine " << addr << " is resumed." << std::endl;

    return 1;
}

int main() {
    typedef copp::coroutine_context_default coroutine_t;

    // create a coroutine
    copp::coroutine_context_default::ptr_t co_obj = coroutine_t::create(my_runner);
    std::cout << "cortoutine " << co_obj << " is created." << std::endl;

    // start a coroutine
    co_obj->start();

    // yield from my_runner
    std::cout << "cortoutine " << co_obj << " is yield." << std::endl;
    co_obj->resume();

    std::cout << "cortoutine " << co_obj << " exit and return " << co_obj->get_ret_code() << "." << std::endl;
    return 0;
}
~~~~~~~~~~

Also, you can use copp::coroutine_context_container<ALLOCATOR> instead of copp::coroutine_context_default to use a different stack allocator.

#### coroutine task example
This is a simple example of using coroutine task with lambda expression:

~~~~~~~~~~cpp
// see https://github.com/owt5008137/libcopp/blob/v2/sample/sample_readme_2.cpp
#include <iostream>

// include task header file
#include <libcotask/task.h>

typedef cotask::task<> my_task_t;

int main(int argc, char *argv[]) {
#if defined(UTIL_CONFIG_COMPILER_CXX_LAMBDAS) && UTIL_CONFIG_COMPILER_CXX_LAMBDAS
    // create a task using factory function [with lambda expression]
    my_task_t::ptr_t task = my_task_t::create([]() {
        std::cout << "task " << cotask::this_task::get<my_task_t>()->get_id() << " started" << std::endl;
        cotask::this_task::get_task()->yield();
        std::cout << "task " << cotask::this_task::get<my_task_t>()->get_id() << " resumed" << std::endl;
        return 0;
    });

    std::cout << "task " << task->get_id() << " created" << std::endl;
    // start a task
    task->start();

    std::cout << "task " << task->get_id() << " yield" << std::endl;
    task->resume();
    std::cout << "task " << task->get_id() << " stoped, ready to be destroyed." << std::endl;
#else
    std::cerr << "lambda not supported, this sample is not available." << std::endl;
#endif
    return 0;
}
~~~~~~~~~~
Also, you can your stack allocator or id allocator by setting different parameters in template class **cotask::task<TCO_MACRO>**

#### using coroutine task manager
This is a simple example of using task manager:

~~~~~~~~~~cpp
// see https://github.com/owt5008137/libcopp/blob/v2/sample/sample_readme_3.cpp
#include <cstdio>
#include <cstring>
#include <ctime>
#include <inttypes.h>
#include <iostream>
#include <stdint.h>

// include context header file
#include <libcotask/task.h>
#include <libcotask/task_manager.h>

// create a task manager
typedef cotask::task<> my_task_t;
typedef my_task_t::ptr_t task_ptr_type;
typedef cotask::task_manager<my_task_t> mgr_t;
mgr_t::ptr_t task_mgr = mgr_t::create();

// If you task manager to manage timeout, it's important to call tick interval

void tick() {
    // the first parameter is second, and the second is nanosecond
    task_mgr->tick(time(NULL), 0);
}

int main() {
#if defined(UTIL_CONFIG_COMPILER_CXX_LAMBDAS) && UTIL_CONFIG_COMPILER_CXX_LAMBDAS
    // create two coroutine task
    task_ptr_type co_task = my_task_t::create([]() {
        std::cout << "task " << cotask::this_task::get<my_task_t>()->get_id() << " started" << std::endl;
        cotask::this_task::get_task()->yield();
        std::cout << "task " << cotask::this_task::get<my_task_t>()->get_id() << " resumed" << std::endl;
        return 0;
    });
    task_ptr_type co_another_task = my_task_t::create([]() {
        std::cout << "task " << cotask::this_task::get<my_task_t>()->get_id() << " started" << std::endl;
        cotask::this_task::get_task()->yield();
        std::cout << "task " << cotask::this_task::get<my_task_t>()->get_id() << " resumed" << std::endl;
        return 0;
    });


    int res = task_mgr->add_task(co_task, 5, 0); // add task and setup 5s for timeout
    if (res < 0) {
        std::cerr << "some error: " << res << std::endl;
        return res;
    }

    res = task_mgr->add_task(co_another_task); // add task without timeout
    if (res < 0) {
        std::cerr << "some error: " << res << std::endl;
        return res;
    }

    res = task_mgr->start(co_task->get_id());
    if (res < 0) {
        std::cerr << "start task " << co_task->get_id() << " failed, error code: " << res << std::endl;
    }

    res = task_mgr->start(co_another_task->get_id());
    if (res < 0) {
        std::cerr << "start task " << co_another_task->get_id() << " failed, error code: " << res << std::endl;
    }

    res = task_mgr->resume(co_task->get_id());
    if (res < 0) {
        std::cerr << "resume task " << co_task->get_id() << " failed, error code: " << res << std::endl;
    }

    res = task_mgr->kill(co_another_task->get_id());
    if (res < 0) {
        std::cerr << "kill task " << co_another_task->get_id() << " failed, error code: " << res << std::endl;
    } else {
        std::cout << "kill task " << co_another_task->get_id() << " finished." << std::endl;
    }

#else
    std::cerr << "lambda not supported, this sample is not available." << std::endl;
#endif
    return 0;
}
~~~~~~~~~~

#### using stack pool
This is a simple example of using stack pool for cotask:

~~~~~~~~~~cpp
// see https://github.com/owt5008137/libcopp/blob/v2/sample/sample_readme_4.cpp
#include <cstdio>
#include <cstring>
#include <ctime>
#include <inttypes.h>
#include <iostream>
#include <stdint.h>

// include context header file
#include <libcopp/stack/stack_pool.h>
#include <libcotask/task.h>

// define the stack pool type
typedef copp::stack_pool<copp::allocator::default_statck_allocator> stack_pool_t;

// define how to create coroutine context
struct sample_macro_coroutine {
    typedef copp::allocator::stack_allocator_pool<stack_pool_t> stack_allocator_t;
    typedef copp::coroutine_context_container<stack_allocator_t> coroutine_t;
};

// create a stack pool
static stack_pool_t::ptr_t global_stack_pool = stack_pool_t::create();

typedef cotask::task<sample_macro_coroutine> sample_task_t;

int main() {
#if defined(UTIL_CONFIG_COMPILER_CXX_LAMBDAS) && UTIL_CONFIG_COMPILER_CXX_LAMBDAS

    global_stack_pool->set_min_stack_number(4);
    std::cout << "stack pool=> used stack number: " << global_stack_pool->get_limit().used_stack_number
              << ", used stack size: " << global_stack_pool->get_limit().used_stack_size
              << ", free stack number: " << global_stack_pool->get_limit().free_stack_number
              << ", free stack size: " << global_stack_pool->get_limit().free_stack_size << std::endl;
    // create two coroutine task
    {
        copp::allocator::stack_allocator_pool<stack_pool_t> alloc(global_stack_pool);
        sample_task_t::ptr_t co_task = sample_task_t::create(
            []() {
                std::cout << "task " << cotask::this_task::get<sample_task_t>()->get_id() << " started" << std::endl;
                cotask::this_task::get_task()->yield();
                std::cout << "task " << cotask::this_task::get<sample_task_t>()->get_id() << " resumed" << std::endl;
                return 0;
            },
            alloc);

        if (!co_task) {
            std::cerr << "create coroutine task with stack pool failed" << std::endl;
            return 0;
        }

        std::cout << "stack pool=> used stack number: " << global_stack_pool->get_limit().used_stack_number
                  << ", used stack size: " << global_stack_pool->get_limit().used_stack_size
                  << ", free stack number: " << global_stack_pool->get_limit().free_stack_number
                  << ", free stack size: " << global_stack_pool->get_limit().free_stack_size << std::endl;


        // ..., then do anything you want to do with these tasks
    }

    std::cout << "stack pool=> used stack number: " << global_stack_pool->get_limit().used_stack_number
              << ", used stack size: " << global_stack_pool->get_limit().used_stack_size
              << ", free stack number: " << global_stack_pool->get_limit().free_stack_number
              << ", free stack size: " << global_stack_pool->get_limit().free_stack_size << std::endl;

    {
        copp::allocator::stack_allocator_pool<stack_pool_t> alloc(global_stack_pool);
        sample_task_t::ptr_t co_another_task = sample_task_t::create(
            []() {
                std::cout << "task " << cotask::this_task::get<sample_task_t>()->get_id() << " started" << std::endl;
                cotask::this_task::get_task()->yield();
                std::cout << "task " << cotask::this_task::get<sample_task_t>()->get_id() << " resumed" << std::endl;
                return 0;
            },
            alloc);

        if (!co_another_task) {
            std::cerr << "create coroutine task with stack pool failed" << std::endl;
            return 0;
        }

        // ..., then do anything you want to do with these tasks
    }

    std::cout << "stack pool=> used stack number: " << global_stack_pool->get_limit().used_stack_number
              << ", used stack size: " << global_stack_pool->get_limit().used_stack_size
              << ", free stack number: " << global_stack_pool->get_limit().free_stack_number
              << ", free stack size: " << global_stack_pool->get_limit().free_stack_size << std::endl;
#else
    std::cerr << "lambda not supported, this sample is not available." << std::endl;
#endif
    return 0;
}
~~~~~~~~~~

#### using then or await_task
This is a simple example of using ```then``` and ```await_task``` for cotask:

~~~~~~~~~~cpp
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <inttypes.h>
#include <stdint.h>
#include <vector>

// include manager header file
#include <libcotask/task.h>

#if defined(LIBCOTASK_MACRO_ENABLED) && defined(UTIL_CONFIG_COMPILER_CXX_LAMBDAS) && UTIL_CONFIG_COMPILER_CXX_LAMBDAS

typedef cotask::task<> my_task_t;

int main(int argc, char *argv[]) {
    int test_code = 128;

    // create a task using lambda expression
    my_task_t::ptr_t first_task = my_task_t::create([&]() {
        puts("|first task running and will be yield ...");
        cotask::this_task::get_task()->yield();
        puts("|first task resumed ...");
        printf("test code already reset => %d\n", ++test_code);
    });

    // add many then task using lambda expression
    first_task
        ->then([=]() {
            puts("|second task running...");
            printf("test code should be inited 128 => %d\n", test_code);
        })
        ->then([&]() {
            puts("|haha ... this is the third task.");
            printf("test code is the same => %d\n", ++test_code);
            return "return value will be ignored";
        })
        ->then(
            [&](void *priv_data) {
                puts("|it's boring");
                printf("test code is %d\n", ++test_code);
                assert(&test_code == priv_data);
                return 0;
            },
            &test_code);

    test_code = 0;
    // start a task
    first_task->start();
    first_task->resume();

    // these code below will failed.
    first_task->then([]() {
        puts("this will run immediately.");
        return 0;
    });

    my_task_t::ptr_t await_task = my_task_t::create([&]() {
        puts("await_task for first_task.");
        return 0;
    });
    await_task->await_task(first_task);

    printf("|task start twice will failed: %d\n", first_task->start());
    printf("|test_code end with %d\n", test_code);
    return 0;
}
#else
int main() {
    puts("this sample require cotask enabled and compiler support c++11");
    return 0;
}
#endif
~~~~~~~~~~


#### using copp::future::future_t and prepare for c++20 coroutine

This is a simple example of using copp::future::future_t<RESULT> and using copp::future::context<RESULT>:

~~~~~~~~~~cpp
#include <assert.h>
#include <iostream>
#include <list>

// include manager header file
#include <libcopp/future/future.h>
#include <libcopp/future/context.h>

struct example_result_message_t {
    int return_code;
    int response_code;
};
struct example_poller;

typedef copp::future::result_t<
    example_result_message_t, // polled data if success
    int                       // error code if failed
> example_result_t;
typedef copp::future::future_t<example_result_t> example_future_t;
typedef copp::future::context_t<example_poller> example_context_t;

std::list<example_context_t*> g_executor;

struct example_poller {
    example_result_t::storage_type* result;
    std::list<example_context_t*>::iterator iter;
    example_poller(): result(NULL) {
        iter = g_executor.end();
    }
    ~example_poller() {
        // cleanup and remove from executor
        if (iter != g_executor.end()) {
            g_executor.erase(iter);
        }
    }
    void operator()(example_future_t& future, example_context_t &ctx) {
        if (NULL != result) {
            future.poll_data() = *result;
            result = NULL;
            // remove from executor
            if (iter != g_executor.end()) {
                g_executor.erase(iter);
                iter = g_executor.end();
            }
        } else {
            // add to executor
            if (iter == g_executor.end()) {
                iter = g_executor.insert(g_executor.end(), &ctx);
            }
        }
    }
};

void run_with_custom_context () {
    example_future_t future;
    example_context_t context;

    assert(future.is_ready() == false);

    // poll context for the first time and setup waker
    // future should only poll one context
    future.poll(context);

    while (!g_executor.empty()) {
        example_result_message_t msg;
        // set a result message
        msg.return_code = 0;
        msg.response_code = 200;
        // if both success type and error type is a small trivial type, storage_type will be result_t with union of success type and error type
        // else storage_type will be std::unique_ptr<result_t>
        // result_t::make_success(...) and result_t::make_error(...) will make sure to use the correct storage type
        example_result_t::storage_type result_storage = example_result_t::make_success(msg);
        (*g_executor.begin())->get_private_data().result = &result_storage;
        // just call context_t::wake to wakeup and poll again
        (*g_executor.begin())->wake();
    }

    // Then future is ready
    assert(future.is_ready() == true);
    example_result_t* result = future.data();
    assert(result != NULL);
    
    assert(result->is_success());
    assert(200 == result->get_success()->response_code);
    assert(false == result->is_error());
    assert(NULL == result->get_error());

    std::cout<< "Got future success response code: "<< result->get_success()->response_code<< std::endl;
}

static void custom_poller_function(copp::future::context_t<void> & ctx, copp::future::context_t<void>::poll_event_data_t evt_data) {
    if (NULL == evt_data.private_data) {
        return;
    }

    example_future_t* future = reinterpret_cast<example_future_t*>(evt_data.future_ptr);

    example_result_message_t* msg = reinterpret_cast<example_result_message_t*>(evt_data.private_data);

    // if both success type and error type is a small trivial type, storage_type will be result_t with union of success type and error type
    // else storage_type will be std::unique_ptr<result_t>
    // result_t::make_success(...) and result_t::make_error(...) will make sure to use the correct storage type
    future->poll_data() = example_result_t::make_success(*msg);
}

void run_with_void_context () {
    example_future_t future;
    copp::future::context_t<void> context(copp::future::context_t<void>::construct(custom_poller_function));
    // upper code equal to:
    // copp::future::context_t<void> context;
    // context.set_poll_fn(custom_poller_function);

    assert(future.is_ready() == false);

    // poll context for the first time and setup waker
    // future should only poll one context
    future.poll(context);

    while (!future.is_ready()) {
        example_result_message_t msg;
        // set a result message
        msg.return_code = 0;
        msg.response_code = 200;
        context.set_private_data(reinterpret_cast<void*>(&msg));
        
        context.wake();
    }

    // Then future is ready
    assert(future.is_ready() == true);
    example_result_t* result = future.data();
    assert(result != NULL);
    
    assert(result->is_success());
    assert(200 == result->get_success()->response_code);
    assert(false == result->is_error());
    assert(NULL == result->get_error());

    std::cout<< "Got future success response code(context_t<void>): "<< result->get_success()->response_code<< std::endl;
}

int main() {
    run_with_custom_context();
    run_with_void_context();
    return 0;
}
~~~~~~~~~~

#### using c++20 coroutine

~~~~~~~~~~cpp
#include <iostream>

// include manager header file
#include <libcopp/future/std_coroutine_task.h>

#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) && LIBCOPP_MACRO_ENABLE_STD_COROUTINE

static copp::future::task_t<int> call_for_coroutine_task_with_int_result() {
    // ... any code
    co_return 123;
}

static copp::future::task_t<void> call_for_coroutine_task_with_void_result() {
    // ... any code
    co_return;
}

int main() {
    copp::future::task_t<int> t1 = call_for_coroutine_task_with_int_result();
    copp::future::task_t<void> t2 = call_for_coroutine_task_with_void_result();
    std::cout<< "Coroutine t1: "<< t1.get_task_id()<< " -> "<< *t1.data()<< std::endl;
    std::cout<< "Coroutine t2: "<< t2.get_task_id()<< " -> "<< (t2.done()? "done": "running")<< std::endl;
    return 0;
}
#else
int main() {
    puts("this sample require cotask enabled and compiler support c++20 coroutine");
    return 0;
}
#endif
~~~~~~~~~~


#### using c++20 coroutine with custom generator

~~~~~~~~~~cpp
#include <assert.h>
#include <iostream>
#include <string>

// include manager header file
#include <libcopp/future/std_coroutine_task.h>
#include <libcopp/future/std_coroutine_generator.h>

#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) && LIBCOPP_MACRO_ENABLE_STD_COROUTINE

struct sample_message_t {
    int ret_code;
    std::string response;
};

struct sample_generator_waker_t;

typedef copp::future::result_t<sample_message_t, int32_t> sample_result_t;
typedef copp::future::task_t<sample_result_t>             sample_task_t;
typedef copp::future::generator_future_t<sample_result_t> sample_future_t;
typedef copp::future::generator_context_t<sample_generator_waker_t> sample_generator_context_t;


std::list<std::pair<sample_generator_context_t *, std::string> > g_sample_executor;

struct sample_generator_waker_t {
    int32_t code;
    std::list<std::pair<sample_generator_context_t *, std::string> >::iterator refer_to;

    // All parameter passed into generator will be forward here
    sample_generator_waker_t(int32_t c) : code(c) {
        refer_to = g_sample_executor.end();
    }

    ~sample_generator_waker_t() {
        if (refer_to != g_sample_executor.end()) {
            g_sample_executor.erase(refer_to);
        }
    }

    void operator()(sample_future_t &fut, sample_generator_context_t &ctx) {
        if (refer_to == g_sample_executor.end()) {
            // Add to custom executor when first polled
            refer_to = g_sample_executor.insert(
                g_sample_executor.end(), 
                std::make_pair(&ctx, std::string())
            );
            return;
        }

        if (!(*refer_to).second.empty()) {
            // generator finished and produce a result message
            sample_message_t msg;
            msg.ret_code    = code;
            msg.response.swap((*refer_to).second);
            fut.poll_data() = sample_result_t::make_success(msg);

            g_sample_executor.erase(refer_to);
            refer_to = g_sample_executor.end();
        }
    }
};
typedef copp::future::generator_t<sample_result_t, sample_generator_waker_t> sample_generator_t;

static copp::future::task_t<void> call_for_noop_task() {
    co_return;
}

static copp::future::task_t<int> call_for_coroutine_task() {
    // We can start a subtask and await it
    copp::future::task_t<void> t = call_for_noop_task();
    co_await t;
    
    sample_generator_t generator = copp::future::make_generator<sample_generator_t>(200);
    auto result = co_await generator;

    if (result) {
        if (result->is_success()) {
            std::cout<< "Got response message: "<< result->get_success()->response<< std::endl;
            co_return result->get_success()->ret_code;    
        } else {
            co_return *result->get_error();
        }
    }
    co_return 0;
}

int main() {
    copp::future::task_t<int> t = call_for_coroutine_task();
    assert(false == t.done());
    assert(NULL == t.data());  // Task isn't finished and has no data

    while (!g_sample_executor.empty()) {
        // async jobs finished and wake coroutine here
        g_sample_executor.begin()->second = "Hello World!";
        g_sample_executor.begin()->first->wake();
    }

    assert(t.done());
    assert(t.data()); // Task is finished and has data
    std::cout<< "Task "<< t.get_task_id()<< " finished and got result: "<< *t.data()<< std::endl;
    return 0;
}
#else
int main() {
    puts("this sample require cotask enabled and compiler support c++20 coroutine");
    return 0;
}
#endif
~~~~~~~~~~

#### let c++20 coroutine work with cotask::task<MACRO>

This is a simple example to let c++20 coroutine await cotask::task

~~~~~~~~~~cpp
#include <iostream>

// include manager header file
#include <libcopp/future/std_coroutine_task.h>
#include <libcotask/task.h>

#if defined(LIBCOPP_MACRO_ENABLE_STD_COROUTINE) && LIBCOPP_MACRO_ENABLE_STD_COROUTINE

typedef cotask::task<> my_task_t;

static copp::future::task_t<int> call_for_await_cotask(my_task_t::ptr_t t) {
    if (t) {
        co_return co_await t;
    }

    co_return 0;
}

static int cotask_action_callback(void *) {
    int ret = 234;
    void* ptr = nullptr;
    cotask::this_task::get_task()->yield(&ptr);
    if (ptr != nullptr) {
        ret = *reinterpret_cast<int*>(ptr);
    }
    return ret;
}

int main() {
    my_task_t::ptr_t co_task = my_task_t::create(cotask_action_callback);

    auto t = call_for_await_cotask(co_task);
    co_task->start();

    int res = 345;
    co_task->resume(reinterpret_cast<void*>(&res));

    if (nullptr != t.data()) {
        std::cout<< "co_await a cotask::task and get result: "<< *t.data()<< std::endl;
    }
    return 0;
}
#else
int main() {
    puts("this sample require cotask enabled and compiler support c++20 coroutine");
    return 0;
}
#endif
~~~~~~~~~~

Working draft，more details can be seen at https://github.com/owt5008137/libcopp/blob/dev/test/case/future_and_std_coroutine_test.cpp .

NOTICE
----------------

Split stack support: if in Linux and user gcc 4.7.0 or upper, add -DLIBCOPP\_ENABLE\_SEGMENTED\_STACKS=YES to use split stack supported context.

It's recommanded to use stack pool instead of gcc splited stack.

BENCHMARK
----------------

Please see CI output for latest benchmark report. the [benchmark on Linux and macOS can be see here](https://travis-ci.org/owt5008137/libcopp) and the [benchmark on Windows can be see here](https://ci.appveyor.com/project/owt5008137/libcopp).

FAQ
----------------

Q: How to enable c++20 coroutine

> ANS: Add ```/std:c++latest /await``` for MSVC or add ```-std=c++20 -fcoroutines-ts -stdlib=libc++``` for clang or add ```-std=c++20 -fcoroutines``` for gcc.

Q: Will libcopp handle exception?

> ANS: When using c++11 or above, libcopp will catch all unhandled exception and rethrow it after coroutine resumed.

Q: Why ```SetUnhandledExceptionFilter``` can not catch the unhandled exception in a coroutine?

> ANS: Please use ```AddVectoredExceptionHandler``` for tempolary, we will implement WinFiber in the future, and then ```SetUnhandledExceptionFilter``` will work.

FEEDBACK
----------------

If you has any question, please create a issue and provide the information of your environments. For example:

+ **OS**: Windows 10 Pro 19041 *(This can be see after running ```msinfo32```)* / Manjaro(Arch) Linux Linux 5.4.39-1-MANJARO
+ **Compiler**: Visual Studio 2019 C++ 16.5.5 with VS 2019 C++ v14.25 or MSVC 1925/ gcc 9.3.0
+ **CMake Commands**: ```cmake .. -G "Visual Studio 16 2019" -A x64 -DLIBCOPP_FCONTEXT_USE_TSX=ON -DPROJECT_ENABLE_UNITTEST=ON -DPROJECT_ENABLE_SAMPLE=ON -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_PREFIX=%cd%/install-prefix``` / ```cmake .. -G Ninja -DLIBCOPP_FCONTEXT_USE_TSX=ON -DPROJECT_ENABLE_UNITTEST=ON -DPROJECT_ENABLE_SAMPLE=ON -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_PREFIX=/opt/libcopp```
+ **Compile Commands**: ```cmake --build . -j```
+ **Related Environment Variables**: Please provide all the environment variables which will change the cmake toolchain, ```CC``` 、 ```CXX``` 、 ```AR``` and etc.


DEVELOPER
----------------

Documents can be found at https://libcopp.atframe.work (Generated by doxygen with *[docs/libcopp.doxyfile](docs/libcopp.doxyfile)*).


CONSTRIBUTORS
----------------
+ [owent](https://github.com/owt5008137)

THANKS TO
----------------

+ [mutouyun](https://github.com/mutouyun)
